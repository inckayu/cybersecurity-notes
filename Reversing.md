# 解析の種類
## 表層解析
実行可能ファイルの種類やアーキテクチャなど、プログラムの概要を調べる。`file`コマンドや`strings`コマンドなどを用いる。
## 動的解析
実際にプログラムを動かして処理を調べる。`gdb`コマンドなどを用いる。
## 静的解析
プログラムを実行せずにバイナリ中に書かれたプログラムの処理を読む。逆アセンブルを行いアセンブリ言語を解読する。`IDA`というツールなどを用いる。
# プログラムが動く仕組み
## CPUとメモリ
CPUが計算、メモリがデータの記憶を担当する。プログラムの実行においてはメモリに展開したプログラムのデータをCPUが取得し、計算した結果をメモリに保存するという流れを何度も繰り返している。
メモリ上の値を取得するにはアドレスという数字を指定して取得する。データをメモリ上に保存する際も同様にアドレスを指定して書き込む先を決める。
## レジスタ
CPUにはメモリから取得したデータを一時的に保存するレジスタという小さな記憶領域が存在する。レジスタにはいくつかの種類があり、それぞれ名前を持つ。メモリはアドレスを用いて参照するが、レジスタは名前を用いて参照する。
`x86-64`のAMDアーキテクチャでは主に以下のレジスタがある。

| 名前       | 意味                | 用途                       |
| -------- | ----------------- | ------------------------ |
| `rax`    | Accumlator        | 汎用レジスタ                   |
| `rcx`    | Counter           | 汎用レジスタ。カウンタとして使われることが多い。 |
| `rdx`    | Data              | 汎用レジスタ                   |
| `rbx`    | Base              | 汎用レジスタ                   |
| `rsi`    | Source Index      | 汎用レジスタ。データを読むメモリのアドレス    |
| `rdi`    | Destination Index | 汎用レジスタ。データを書くメモリのアドレス    |
| `r8-r15` | 特になし              | 汎用レジスタ                   |
| `rsp`    | Stack Pointer     | スタックの先頭を指す               |
| `rbp`    | Base Pointer      | ローカル変数の参照で用いられる          |
レジスタは簡易的な記憶領域なので64ビットアーキテクチャの場合は64ビット(8バイト)の値しか保存できない。64ビットのレジスタのうち、下位32ビットや8ビットだけ利用することも可能で、その場合はレジスタの名前が以下のように変化する。

| 64ビット | 32ビット        | 16ビット           | 下位2バイト目 | 最下位バイト |
| ----- | ------------ | --------------- | ------- | ------ |
| `rax` | `eax`        | `ax`            | `ah`    | `al`   |
| `rdx` | `edx`        | `dx`            | `dh`    | `dl`   |
| `rsi` | `esi`        | `si`            |         | `sil`  |
| `rdi` | `edi`        | `di`            |         | `dil`  |
| `rsp` | `esp`        | `sp`            |         | `spl`  |
| `rbp` | `ebp`        | `bp`            |         | `bpl`  |
| `r8`  | `r8d`        | `r8w`           |         | `r8b`  |
| `r12` | `r12d`       | `r12w`          |         | `r12b` |
# アセンブリ言語
CPUが解釈して実行する命令列を機械語と呼ぶ。Reversingの際には機械語を逆アセンブルして出力されたアセンブリ言語を読む。機械語の命令とアセンブリ言語の命令は一対一に対応している。
機械語はメモリ上に存在する。実行ファイルを実行するとOSが実行ファイルの機械語をメモリ上に展開し、その先頭(エントリポイント)から1命令ずつCPUが実行する。そのためメモリ上の変数などの情報と同じように機械語の各命令にもアドレスが存在する。`rip`という特殊なレジスタが次に実行する命令のアドレスを指す。CPUは`rip`の指す先から次の命令を読み込んで実行するという一連の処理をプログラムが終了するまで繰り返す。
ちなみに機械語やアセンブリ言語からC言語のような高級言語に戻ること(逆コンパイル)は一般的には困難になる。ただし中間言語を持つC#やJavaのような言語の場合はほぼ完全にソースコードに戻すことができる。
## objdump
機械語をアセンブリ言語に変換するツール。`-S`オプションをを渡してELFファイルを指定すると逆アセンブル結果を表示する。`-M intel`をつけるとIntel記法での出力になる。
実行例
```bash
objdump -S -M intel /bin/true
```

| オプション                  | 説明                                  |
| ---------------------- | ----------------------------------- |
| `-d`                   | `.text` セクションを逆アセンブルする              |
| `-D`                   | すべてのセクションを逆アセンブルする                  |
| `-M intel`             | 逆アセンブルを Intel 記法で表示（デフォルトは AT&T 記法） |
| `-t`                   | シンボルテーブルを表示（関数や変数の一覧）               |
| `-T`                   | 動的シンボルテーブルを表示（共有ライブラリ関連）            |
| `-x`                   | ファイルの詳細情報（ヘッダ・シンボルなど）をまとめて表示        |
| `-h`                   | セクションヘッダ一覧を表示（サイズ・VMA・オフセットなど）      |
| `-s`                   | セクションの生データを 16進＋ASCII で表示           |
| `-r`                   | リロケーション情報を表示                        |
| `-g`                   | デバッグ情報（DWARF など）を表示                 |
| `-f`                   | ファイルヘッダを表示（アーキテクチャ・エントリポイントなど）      |
| `--start-address=ADDR` | 指定アドレス以降だけ逆アセンブル表示                  |
| `--stop-address=ADDR`  | 指定アドレスまで逆アセンブル表示                    |
| `--no-show-raw-insn`   | 機械語部分を出力しない                         |
なお16進数は一般的に`0xAB`のように頭に `0x`をつけて表すことが多いが、intel表記では`ABh`のように末尾に`h`をつけて表す。
2進数は頭に`0b`あるいは末尾に`b`をつけて表す。
# アセンブリ言語
## 基礎的な記法
### オペコードとオペランド
アセンブリ言語の命令は1個のオペコードと0個以上のオペランドと呼ばれる2つのパーツに分けられる。オペコードは命令の種類を表し、オペランドは命令の引数(命令の対象)を表す。オペランドにはレジスタの名前・メモリのアドレス・具体的な数値が入る。
例えば`rax`レジスタに10を足すという命令は以下。
```assembly
add rax, 10
```
この命令においてオペコードは`add`, オペランドは`rax`と`10`になる。1つ目のオペランドを第一オペランド、2つ目を第二オペランドと呼ぶ。第一オペランドはしばしば宛先(destination)になる。宛先とは命令により変更を受けるレジスタやメモリを意味する。今回の場合、第一オペランドの`rax`には`10`が加算され`rax`レジスタの値が変更される。
一方で変更を受けない(値が読み出される)レジスタやメモリをソース(source)と呼ぶ。
オペランドに数値がそのまま書かれている場合、これを即値と呼ぶ。上の例では`10`が即値となる。
### レジスタとメモリ
アセンブリ言語でレジスタを扱う際はレジスタの名前をそのまま書くが、メモリを参照する場合は`[]`でアドレスを囲み、サイズを示す接頭辞(プレフィックス)をつける。

| 接頭辞     | 意味          | サイズ(バイト) |
| ------- | ----------- | -------- |
| `QWORD` | Quad Word   | 8        |
| `DWORD` | Double Word | 4        |
| `WORD`  | Word        | 2        |
| `BYTE`  | Byte        | 1        |
例えばメモリの`0x602060`番地から4バイトだけデータを取得する場合は以下のように書く。
```assembly
mov eax, DWORD [0x602060]
```
メモリの番地を表す括弧の中にはレジスタを使うこともできる。
```assembly
mov rax, QWORD [rdi]
```
レジスタと即値の加減算や掛け算をすることもできる。
```assembly
mov rdx, QWORD [rdi+rcx*8-0xf8]
```
なお、一つの括弧の中では3つ以上のレジスタは同時に使えない、掛ける値は2の累乗の形で64ビットまでのような制約がある。
アセンブリ言語の記法によっては`DWORD`や`QWORD`の後に`PTR`(ポインタ)をつけて以下のように書く場合もある。
```assembly
mov eax, DWORD PTR [0x602060]
```
### ラベル
アセンブリで分岐や関数呼び出しをする際に、その分岐先や関数の名前を定義しておく必要がある。名前にコロン(`:`) をつけることで命令ではなくラベルとして認識される。
以下のコードは`label01`というラベルにジャンプしている。
```assembly
jmp label01
...
label01
...
```
### コメントアウト
アセンブリではセミコロン(`;`)をつけるとその行のセミコロン以降はコメントアウトされる。
```assembly
add rax, 10 ; raxに10を足す
```
## mov命令
`mov`命令は二つのオペランドを取る。
```assembly
mov A, B
```
これは`A`に`B`の値を代入せよという命令を意味する。第一オペランド(宛先)にはレジスタとメモリを指定でき、第二オペランド(ソース)にはレジスタとメモリ以外に即値も指定できる。
### 即値の代入
`rax`レジスタに`1`を代入する。
```assembly
mov rax, 1
```
`dl`レジスタに`0x15`を代入する。
```assembly
mov dl, 0x15
```
`dl`レジスタは`rdx`レジスタの下位1バイトなので、例えば`rdx`レジスタにもともと`0x1234`という値が入っていた場合、この命令の実行後には`rdx`レジスタには`0x1215`が入る。
**16進数の1桁は4ビットを示す**(`2^4 = 16`)ので`0x15`という16進数で2桁の数は8ビットで表現できる。したがって下位1バイト(8ビット)を示す`dl`レジスタに`0x15`を代入できる。
### レジスタ間での値の転送
`rbx` レジスタの値を`rcx`レジスタに転送する。
```assembly
mov rbx, rcx
```
### メモリから値を転送
```assembly
mov rax, QWORD PRR [0x602060]
```
`QWORD` は8バイトなので`rax`レジスタにはメモリの`0x602060`番地から`0x602068`番地までの8バイトの値が代入される。
### メモリへ値を転送
`rdx`レジスタの値をメモリ上の`rdi`番地に代入する。
```assembly
mov QWORD PTR [rdi], rdx
```
`rdi`にはメモリのアドレスが入っているので`rdi`に`0x602060`が入っている場合は`0x602060`番地になる。

`mov`命令を用いることでメモリとレジスタ間でデータの転送ができるようになるが、メモリからメモリへの転送はできないことに注意。このような転送を行いたい場合は一度レジスタを経由する必要がある。
```assembly
mov rax, QWORD PTR [rdi]
mov QWORD PTR [rsi], rax
```
### 拡張mov命令
`movsx`と`movzx`という命令はサイズ小さいレジスタ/メモリから大きいレジスタに値を移すために用いられる。`mov`命令では第一オペランドと第二オペランドのサイズが同じである必要があるが、これらの命令は第一オペランドのほうがサイズが大きい。`movsx`は符号付き(signed)拡張で`movzx`はゼロ(zero)拡張。
`short`型から`long`型、`char`型から`unsigned int`型など符号付きの型からの拡張は符号付き拡張`movsx`で表現できる。`unsigned char`型から`long`型、`unsigned short`型から`int`型など符号なしの型からの拡張はゼロ拡張movszで表現できる。
32ビットのデータを64ビットに符号拡張する際は特別に名前が`movsxd`になる。
#### 符号なし整数
すべてのビットを数値そのものとして扱う。
```
11111111b = 255 (unsigned)
00000001b =   1 (unsigned)
```
#### 符号付き整数
最上位ビット(MSB)を符号ビットとして扱う。`0`が正で`1`が負。
```
01111111b = +127
10000000b = -128
11111111b =  -1
```
#### 2の補数表現(Two's Complement)
`-1`を8ビットで表すと
1. +1 = `00000001`
2. ビットを反転　→　`11111110`
3. さらに+1　→　`11111111`
つまり`11111111b`が`-1`になる。
### プレフィックスの省略
メモリとレジスタ間で転送を行う際、多くの命令でデータサイズを表すプレフィックスとレジスタのサイズが一致する必要があるのでプレフィックスが省略される場合がある。
```assembly
mov al, [0x602060]
```
このような記法に遭遇した場合はレジスタのサイズを見て何バイトの操作なのか判断できる。上の例では`al`が`rax`レジスタの下位1バイトを表すのでメモリの`0x602060`番地から1バイト取得することがわかる。
一方以下のような記法は存在しない。
```assembly
mov [0x602060], 0x1234
```
`0x1234`のバイト数が判断できないのでこのような場合は必ずプレフィックスを付ける必要がある。
```assembly
mov WORD PTR [0x602060], 0x1234
```
上の例では`0x1234`が2バイトであることがわかる。
## lea命令(アドレス代入命令)
lea命令はオペランドを2つ取るが、第二オペランドは必ずメモリを指す。第二オペランドの指すアドレスを第一オペランドに代入する。
```assembly
lea A, [B]
```
`0x602060`番地のアドレスを`rax`レジスタに代入する。
```assembly
lea rax, [0x602060]
```
括弧の中ではレジスタと即値の加減算や掛け算を利用することができるので、`lea`命令を使うことで、以下のような複雑な操作を一回の命令で行うことができる。
`rcx`を8倍した値を`rax`に足してその結果を`rdx`に入れる。
```assembly
lea rdx, [rax+rcx*8]
```
`mov`ではアドレスを計算したうえでアドレスが指すメモリの中身を代入するが、`lea`ではアドレスそのものを計算してアドレスの数値自体を代入する。
## 算術演算
### 加減算
それぞれ`add`, `sub`で表す。オペランドを二つ取り、以下のように実現する。
```assembly
add A, B
sub A, B
```
第二オペランドにはレジスタ・メモリの他に即値を指定できる。
```assembly
add rax, rdx
add rax, QWORD PTR [0x602060]
sub rax, 0x1234
```
### インクリメント・デクリメント
 それぞれ`inc`, `dec`で表す。
```assembly
inc rax
dec QWORD PTR [0x602060]
```
### 乗算
`mul` 命令はオペランドを一つだけ取る。
```assembly
mul A
```
`A`には掛ける値が入ったレジスタやメモリを指定する。`rax`レジスタの値と乗算をする。
```assembly
mov rax, 7
mov rcx, 3
mul rcx
```
`mul`命令は第一オペランドがソースになることに注意。計算結果は上半分(上位64ビット)が`rdx`レジスタ、下半分(下位64ビット)が`rax`レジスタに入る。第一オペランドが32ビットのレジスタやメモリの場合は結果の上位32ビットと下位32ビットがそれぞれ`edx`, `eax`に入る。
### 除算
`mul`と同様にソースになるオペランド1つを取る。
```assembly
div A
```
除数(割る数)をオペランドに指定し、被除数(割られる数)を`rax`レジスタに入れておく。商が`rax`レジスタ、剰余が`rdx`レジスタに入る。以下の例では21を5で割るので`rax`, `rdx`レジスタにはそれぞれ4, 1が入る。
```assembly
mov rax, 21
mov rdx, 5
div rdx
```
### imul, idiv
intelのアセンブリで用いられる命令。それぞれ乗算と除算を符号付きで計算する。
## 論理演算
### 論理積
`and`命令は第一オペランドと第二オペランドの論理積を取り、結果を第一オペランドに格納する。
```assembly
and rax, rdx
and QWORD PTR [0x602060], 0xffff
```
### 論理和
`or`命令は同様に第一オペランドと第二オペランドの論理和を取り、結果を第一オペランドに格納する。
### 排他的論理和
`xor`命令を用いる。同様に第一オペランドと第二オペランドの排他的論理和を取り、結果を第一オペランドに格納する。
```assembly
xor rax, rdx
xor QWORD PTR [0x602060], 0xffff
xor eax, eax ; rax = 0にする
```
3つ目の例のように、同じレジスタの排他的論理和を取ることで当該レジスタを0にできる。`eax`同士の排他的論理和ではあるが仕様上`rax`レジスタ全体が0になる。
単に`mov rax, 0`とするよりも機械語にした際のサイズが少ないので好まれる。
### 否
`not`を用いる。第一オペランドの否定を取り、結果を第一オペランドに格納する。
```assembly
not rax
not QWORD PTR [0x602060]
```
## シフト演算
### 論理シフト
`shr`命令と`shl`命令を用いる。それぞれ右シフト、左シフトに相当する。オペランドを1つまたは2つ取り、1つ取る場合はそのレジスタやメモリの値を1ビットシフトする。
```assembly
shl rax; rax <<= 1
shr rax; rax >>= 1
```
オペランドを2つ取る場合は第一オペランドのレジスタやメモリの値を第二オペランドの値だけシフトする。ただし第二オペランドには即値もしくは`cl`レジスタのみ指定できる。`cl`レジスタは`rcx`レジスタの下位1バイト。
```assembly
mv cl, 3
shl rax, cl ; rax <<= 3
shr rax, 17 ; rax >>= 17
```
### 算術シフト
符号付きの値に対するシフト演算。`sar`命令と`sal`命令がある。それぞれ右シフト、左シフトに相当する。
## 比較
一般的な高級言語において、`if`文や`for`文には分岐の条件式がある。アセンブリにはこれらの構文がないので、比較してから分岐するという処理を順に書く必要がある。
### cmp命令
アセンブリの比較命令には`cmp`命令がある。
```assembly
cmp A, B
```
`cmp`命令は第一オペランドと第二オペランドの値を比較してフラグレジスタの値を変更する。
フラグレジスタは32ビットで各ビットには役割がある。

| フラグ  | 意味            | フラグが1になる条件    |
| ---- | ------------- | ------------- |
| `ZF` | Zero Flag     | 演算結果がゼロ       |
| `SF` | Signed Flag   | 演算結果が負        |
| `CF` | Carry Flag    | 通常の演算で桁あふれが発生 |
| `OF` | Overflow Flag | 符号付き演算で桁溢れが発生 |
これまでに説明した`add`や`sub`のような命令も実行するとフラグレジスタの値を変更する。引き算をした結果がゼロになれば`ZF=1`になり、足し算で桁あふれが発生した場合は`CF=1`になる。
`cmp`命令は内部で引き算を実行する。`cmp A, B`という処理が行われる際、`A - B`を内部で行い、結果が0になるか、負になるかなどをチェックしてフラグレジスタを変更している。
次の例では`cmp`命令を実行すると`ZF=1, SF=0, CF=0, OF=0`になる。
```assembly
mov rax, 10
mov rdx, 10
cmp rax, rdx
```
### test命令
比較命令には`cmp`の他に`test`も用いられる。`test`命令は2つのオペランドの論理積を計算してその結果に応じてフラグレジスタの値を書き変える。
この命令はC言語において以下のように変数や関数の戻り値が0か否かを確認する以下のような処理において頻繁に登場する。
```c
if (var) {
...
} else {
...
}
```
このような場合は`test`命令の2つのオペランドを同じ値(var)に設定する。論理積なので`var`が0であれば`ZF=1`になり、それ以外の場合は`ZF=0`になる。
以下の例では`rax`が0のときのみ`ZF=1`になる。
```assembly
test rax, rax
```
## 分岐
### jmp命令
無条件ジャンプを示す。すべての分岐命令はジャンプ先のアドレスを表すオペランド1つを取る。プログラムを逆アセンブルすると分岐命令の引数は一般的にアドレスになるが、アセンブリコードを書く際はラベルを指定することもできる。
```assembly
jmp func ; funcに飛ぶ
...
func: ; ラベルfunc
```
`jmp`命令は無条件ジャンプなのでフラグレジスタの値は関係ない。
### jz, je命令
それぞれ`Jump if Zero`, `Jump if Equal`の略。どちらも`ZF=1`の場合にジャンプする。
以下の例では`rax`が10のときに`cmp`命令で`ZF=1`になるので`jz`でジャンプする。
```assembly
cmp rax, 10
jz a ; ZF=1ならaにジャンプ
... ; rax != 10ならここが実行される
a:
... ; rax == 10ならここが実行される
```
### jnz, jne命令
それぞれ`Jump if Not Zero`, `Jump if Not Equal`の略。`ZF=0`の場合にジャンプする。
以下の例では`rax`が10ではないときに`cmp`命令で`ZF=0`になるので`jne`でジャンプする。
```assembly
cmp rax, 10
jne a
... ; rax == 0の場合はここが実行される
a:
... ; rax != 0の場合はここが実行される
```
### ja, jae命令
それぞれ`Jump if Above`, `Jump if Above or Equal`の略。`>`や`>=`に相当する。`ja`は`CF=0`かつ`ZF=0`のとき、`jae`は`CF=0`のときにジャンプする。
```assembly
cmp rax, 10
ja a ; rax > 10ならaにジャンプ
...
a:
...
```
これら二つの分岐命令は符号無しで値を見ている(`unsigned`型用の分岐)ので負と正の数を比較することはできない。
### jb, jbe命令
それぞれ`Jump if Below`, `Jump if Below or Equal`の略。`jb`は`CF=1`のとき、`jbe`は`CF=1`または`ZF=1`のときにジャンプする。
```assembly
cmp rax, 10
jbe a ; rax <= 10ならaにジャンプ
...
a:
...
```
### jg, jge命令
`ja`や`jae`と同様の機能だが、符号付きで値を比較する。それぞれ`Jump if Greater`, `Jump if Greater or Equal`の略。`jg`は`ZF=0`かつ`SF=OF`のとき、`jge`は`SF=OF`であればジャンプする。
```assembly
cmp rax, -10
jge a ; rax >= 10ならaにジャンプ
...
a:
...
```
### jl, jle命令
`jb`, `jbe`と同様の機能だが、符号付きで値を比較する。それぞれ `Jump if less`, `Jump if Less or Equal`の略。`jl`は`SF != OF`, `jle`は`SF != OF`または`ZF=1`であればジャンプする。
## スタック操作
LIFO(Least In First Out)またはFILO(First In Last Out)のデータ構造。スタックに新しくデータを追加する操作を`push`, データを取得することを`pop`と呼ぶ。
### push, pop
`push`命令はオペランドを一つ持ち、そこに64ビットのレジスタ、メモリ、あるいは即値を指定する。
```assembly
push A
```
`push`命令を実行すると`rsp`が8(QWORD)だけ減算され、メモリ上で`rsp`レジスタの指すアドレスに第一オペランドのデータが積まれる。このとき`rsp`レジスタの指す先がスタックトップになる。
`pop`命令もオペランドを1つ取るが、第一オペランドは必ず64ビットのレジスタになる。`pop`命令を実行するとメモリ上で`rsp`レジスタの指す先にあるデータが第一オペランドで示されたレジスタにコピーされ、`rsp`に8(QWORD)だけ加算される。
もともとスタックトップにあったデータは`pop`しても消されずに残るが、その後`push`されるなどで上書きされると初めて消える。
これらを踏まえると`push`と`pop`はそれぞれ次の処理と等価なことがわかる。
```assembly
; push A
sub rsp, 8
mov QWORD PTR [rsp], A

; pop A
mov A, QWORD PTR [rsp]
add rsp, 8
```
`push`や`pop`はレジスタの値を保存する際によく使われる。以下の例のように書くと、`push`の後ろで`rax`や`rdx`レジスタの値を書き換えても保存した値が最後の`pop`で読み込まれるのでこのコード前後で`rax`と`rdx`レジスタの値は変化しない。
```assembly
push rax
push rdx
;; ここでraxやrdxを上書きしても良い
pop rdx
pop rax
```
## 関数呼び出し
### call, ret
`call`命令は関数呼び出しを行う。`jmp`命令と同様に第一オペランドのアドレスに処理を移動するが、`ret`命令で呼び出し元の場所に戻ることができる。
```assembly
func:
  ...
  ret
main:
  ...
  call func ; funcにジャンプ
  ... ; retでここに戻る
```
`func`関数のように実行が終わると呼び出し元に戻る処理をサブルーチンと呼ぶ。
`call`命令を使うとアセンブリ中で定義した関数以外に外部ライブラリの関数を呼ぶことができる。例えば`puts`関数で`Hello, World!`を出力するプログラムを逆アセンブルすると以下のようなコードが含まれる。
```assembly
00000000004004e7 <main>:
  4004e7:  push  rbp
  4004e8:  mov  rbp,rsp
  4004eb:  lea  rdi,[rip+0x92]
  4004f2:  call  4003f0 <puts@plt>
  4004f7:  mov  eax,0x0
  4004fc:  pop  rbp
  4004fd:  ret
```
この例の場合、アドレス`4004f2`で`call`命令が使われており、呼び出している飛び先のアドレスは`4003f0`だが`objdump`がこれを`puts`であると認識して表示している。
`call`命令はジャンプする前に次の命令(`ret`で戻ってきたい場所)のアドレスをスタックに`push`する。そして`ret`命令はスタックトップにある値を`pop`して`rip`レジスタ(次に実行する場所を示すレジスタ)に設定する。
### 関数の引数
`x86-64`においては基本的にレジスタを用いて引数を渡す。引数の番号とレジスタの対応は以下。

| 引数   | 対応するレジスタ |
| ---- | -------- |
| 第一引数 | `rdi`    |
| 第二引数 | `rsi`    |
| 第三引数 | `rdx`    |
| 第四引数 | `rcx`    |
| 第五引数 | `r8`     |
| 第六引数 | `r9`     |
7個以上の引数を取る場合はスタックを用いて渡す。
```assembly
push 8
push 7
mov r9, 6
mov r8, 5
...
mov rdi, 1
```
関数内では次のような形式で第七引数以降を取得する。
```assembly
mov rax, [rsp+0x08]
mov rbx, [rsp+0x10]
```
なお、関数の戻り値は`rax`レジスタに入る。戻り値の値によってレジスタの種類は`eax`など変化する。
### 関数呼び出しの手順
1. `call`命令で呼び出す関数の先頭にジャンプし、戻り先のアドレスをスタックに積む
2. `rbp` の値をスタックに積んで保存する
3. `rbp`にスタックトップの値を代入する
4. その関数で使いたいローカル変数のサイズを`rsp`から引く
### 関数終了の手順
1. `leave`命令で`rsp`, `rbp`を元に戻す
2. `ret`命令で戻り先アドレスを`pop`し、そこにジャンプする
### leave 命令
`ret`命令の直前で用いられる。`mov rsp, rbp; pop rbp`と等価な命令。`rsp`に`rbp`の値を入れて、スタックトップから`rbp`に値を`pop`するという操作が頻繁に行われることから1つの命令として用意されている。
## システムコール
キーボードからの入力やファイルの読み書きのような処理をユーザが直接実行することはできない。セキュリティ上権限のないユーザが実行してはいけないような処理はシステムコールという方法で実行される。システムコールとはOSに処理を依頼する方法で、`x86-64`では`syscall`という命令が用意されている。
システムコールでOSに処理を依頼するには、処理を示すシステムコール番号とOSにわたす引数を指定する必要がある。`x86-64`ではシステムコール番号を`rax`レジスタにセットする。引数には`rdi, rsi, rdx, r10, r8, r9`レジスタを順番に使う。
## 変数の保存先
### ローカル変数
スタック上で扱う。ローカル変数では`push`や`pop`は用いずに`rbp`からのインデックスとして値を読み書きする。
### グローバル変数
メモリ上の固定アドレス(プログラムの先頭から固定のオフセット離れた位置)で参照される。
### ヒープ
データのサイズが可変な場合において利用される。C言語では`malloc`という関数を用いて領域を確保する。確保した領域は不要になったら`free`関数で開放する必要がある。
```c
char *p = malloc(0x100);
memset(p, 'A', 0x100);
free(p);
```
